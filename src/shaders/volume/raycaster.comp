#version 450

// Vulkan compute shader for volume ray-casting
// Converts the OpenGL fragment shader approach to compute shader
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Output image
layout(binding = 0, rgba8) uniform writeonly image2D u_output_image;

// Input textures
layout(binding = 1) uniform sampler2D u_tex_entry;
layout(binding = 2) uniform sampler2D u_tex_exit;
layout(binding = 3) uniform sampler3D u_tex_volume;
layout(binding = 4) uniform sampler2D u_tex_tf;
layout(binding = 5) uniform sampler2D u_tex_depth; // Optional depth texture

// Uniform buffer
layout(binding = 6, std140) uniform UniformData {
    mat4 u_view_to_model_mat;
    mat4 u_model_to_view_mat;
    mat4 u_inv_proj_mat;
    mat4 u_model_view_proj_mat;

    vec2  u_inv_res;
    float u_time;
    uint  u_enable_depth;

    vec3  u_clip_plane_min;
    float u_tf_min;
    vec3  u_clip_plane_max;
    float u_tf_inv_ext;

    vec3 u_gradient_spacing_world_space;
    uint u_max_steps;

    mat4 u_gradient_spacing_tex_space;

    vec3  u_env_radiance;
    float u_roughness;
    vec3  u_dir_radiance;
    float u_F0;

    // DVR settings
    uint u_dvr_enabled;
    uint u_iso_enabled;
    uint u_temporal_enabled;
    uint u_padding;
};

// Isovalues as push constants for efficiency
layout(push_constant) uniform IsovalueData {
    float values[8];  // MAX_ISOVALUE_COUNT = 8
    vec4  colors[8];
    uint  count;
} u_iso;

#define MAX_ISOVALUE_COUNT 8
#define SHADING_ENABLED

// Helper functions
float getVoxel(vec3 pos) {
    return texture(u_tex_volume, pos).r;
}

vec3 getGradient(vec3 samplePos) {
    vec3 g = vec3(getVoxel(samplePos + u_gradient_spacing_tex_space[0].xyz),
                  getVoxel(samplePos + u_gradient_spacing_tex_space[1].xyz),
                  getVoxel(samplePos + u_gradient_spacing_tex_space[2].xyz));
    
    g -= vec3(getVoxel(samplePos - u_gradient_spacing_tex_space[0].xyz),
              getVoxel(samplePos - u_gradient_spacing_tex_space[1].xyz),
              getVoxel(samplePos - u_gradient_spacing_tex_space[2].xyz));
    
    return g / (2.0 * u_gradient_spacing_world_space);
}

// Cook-Torrance shading model
const vec3 L = normalize(vec3(1,1,1));
const float PI = 3.1415926535;
const float ONE_OVER_PI = 1.0 / 3.1415926535;

float FresnelSchlick(float cosTheta, float F0) {
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float DistributionGGX(float NdotH, float roughness) {
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH2 = NdotH * NdotH;
    float num = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
    return num / denom;
}

float GeometrySchlickGGX(float NdotV, float roughness) {
    float r = (roughness + 1.0);
    float k = (r * r) / 8.0;
    float num = NdotV;
    float denom = NdotV * (1.0 - k) + k;
    return num / denom;
}

float GeometrySmith(float NdotV, float NdotL, float roughness) {
    float ggx2 = GeometrySchlickGGX(NdotV, u_roughness);
    float ggx1 = GeometrySchlickGGX(NdotL, u_roughness);
    return ggx1 * ggx2;
}

vec4 shade(vec4 color, vec3 V, vec3 N) {
    vec3 H = normalize(L + V);
    float H_dot_V = max(0.0, dot(H, V));
    float N_dot_H = max(0.0, dot(N, H));
    float N_dot_L = max(0.0, dot(N, L));
    float N_dot_V = max(0.0, dot(N, V));

    float F0 = u_F0;
    float roughness = u_roughness;
    vec3 dir_radiance = u_dir_radiance;
    vec3 env_radiance = u_env_radiance;

    vec3 albedo = color.rgb * color.a;
    float alpha = color.a;

    vec3 Lo = vec3(0);

    // Directional light contribution
    float NDF = DistributionGGX(N_dot_H, roughness);
    float G = GeometrySmith(N_dot_V, N_dot_L, roughness);
    float F = FresnelSchlick(H_dot_V, F0);
    float kS = F;
    float kD = 1.0 - kS;
    float numerator = NDF * G * F;
    float denominator = 4.0 * N_dot_V * N_dot_L + 0.0001;
    float specular = numerator / denominator;
    Lo += (kD * albedo * ONE_OVER_PI + vec3(specular)) * dir_radiance * N_dot_L;

    // Environment contribution
    F = FresnelSchlick(N_dot_V, F0) * (1.0 - roughness);
    kS = F;
    kD = 1.0 - kS;
    Lo += (kD * albedo * ONE_OVER_PI + vec3(kS)) * env_radiance;
    alpha += kS;

    return vec4(Lo, alpha);
}

vec4 depth_to_view_coord(vec2 tc, float depth) {
    vec4 clip_coord = vec4(vec3(tc, depth) * 2.0 - 1.0, 1.0);
    vec4 view_coord = u_inv_proj_mat * clip_coord;
    return view_coord / view_coord.w;
}

// Volume ray-casting main function
vec4 raycast_volume(vec2 tc) {
    vec3 entry_pos = texture(u_tex_entry, tc).xyz;
    vec3 exit_pos = texture(u_tex_exit, tc).xyz;
    
    // Early exit if no valid entry/exit
    if (entry_pos == vec3(0.0) && exit_pos == vec3(0.0)) {
        return vec4(0.0);
    }

    vec3 ray_dir = exit_pos - entry_pos;
    float ray_length = length(ray_dir);
    
    if (ray_length < 0.001) {
        return vec4(0.0);
    }
    
    ray_dir = normalize(ray_dir);

    // Apply depth testing if enabled
    float max_distance = ray_length;
    if (u_enable_depth != 0u) {
        float depth_sample = texture(u_tex_depth, tc).r;
        if (depth_sample < 1.0) {
            vec4 depth_view = depth_to_view_coord(tc, depth_sample);
            vec4 depth_model = u_view_to_model_mat * depth_view;
            max_distance = min(max_distance, length(depth_model.xyz - entry_pos));
        }
    }

    // Temporal jittering
    float temporal_offset = 0.0;
    if (u_temporal_enabled != 0u) {
        temporal_offset = fract(sin(dot(tc + u_time, vec2(12.9898, 78.233))) * 43758.5453);
    }

    // Ray-casting parameters
    uint max_steps = u_max_steps;
    float step_size = ray_length / float(max_steps);
    float current_distance = temporal_offset * step_size;
    
    vec4 accumulated_color = vec4(0.0);
    bool found_iso = false;

    // Ray-casting loop
    for (uint i = 0u; i < max_steps && current_distance < max_distance; ++i) {
        vec3 sample_pos = entry_pos + ray_dir * current_distance;
        
        // Check bounds
        if (any(lessThan(sample_pos, u_clip_plane_min)) || 
            any(greaterThan(sample_pos, u_clip_plane_max))) {
            current_distance += step_size;
            continue;
        }

        float voxel_value = getVoxel(sample_pos);
        
        // Isosurface rendering
        if (u_iso_enabled != 0u && !found_iso) {
            for (uint iso_idx = 0u; iso_idx < u_iso.count; ++iso_idx) {
                float iso_value = u_iso.values[iso_idx];
                
                if (abs(voxel_value - iso_value) < step_size * 2.0) {
                    vec3 gradient = getGradient(sample_pos);
                    vec3 normal = normalize(gradient);
                    
                    if (length(gradient) > 0.001) {
                        vec3 view_dir = normalize((u_model_to_view_mat * vec4(sample_pos, 1.0)).xyz);
                        vec4 iso_color = u_iso.colors[iso_idx];
                        
                        #ifdef SHADING_ENABLED
                        iso_color = shade(iso_color, -view_dir, normal);
                        #endif
                        
                        accumulated_color = vec4(iso_color.rgb, 1.0);
                        found_iso = true;
                        break;
                    }
                }
            }
        }

        // Direct Volume Rendering (DVR)
        if (u_dvr_enabled != 0u && !found_iso) {
            float tf_coord = (voxel_value - u_tf_min) * u_tf_inv_ext;
            tf_coord = clamp(tf_coord, 0.0, 1.0);
            
            vec4 sample_color = texture(u_tex_tf, vec2(tf_coord, 0.5));
            
            if (sample_color.a > 0.001) {
                #ifdef SHADING_ENABLED
                vec3 gradient = getGradient(sample_pos);
                if (length(gradient) > 0.001) {
                    vec3 normal = normalize(gradient);
                    vec3 view_dir = normalize((u_model_to_view_mat * vec4(sample_pos, 1.0)).xyz);
                    sample_color = shade(sample_color, -view_dir, normal);
                }
                #endif
                
                // Alpha blending
                sample_color.a *= step_size;
                sample_color.rgb *= sample_color.a;
                
                accumulated_color.rgb += sample_color.rgb * (1.0 - accumulated_color.a);
                accumulated_color.a += sample_color.a * (1.0 - accumulated_color.a);
                
                // Early termination
                if (accumulated_color.a > 0.99) {
                    break;
                }
            }
        }

        current_distance += step_size;
    }

    return accumulated_color;
}

void main() {
    ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 image_size = imageSize(u_output_image);
    
    // Bounds check
    if (pixel_coord.x >= image_size.x || pixel_coord.y >= image_size.y) {
        return;
    }

    vec2 tc = (vec2(pixel_coord) + 0.5) / vec2(image_size);
    
    vec4 color = raycast_volume(tc);
    
    imageStore(u_output_image, pixel_coord, color);
}